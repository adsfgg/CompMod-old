-- ======= Copyright (c) 2019, Unknown Worlds Entertainment, Inc. All rights reserved. =============
--
-- lua/menu2/GUIMenuLabel.lua
--
--    Created by:   Trevor Harris (trevor@naturalselection2.com)
--
--    GUIText with menu FX/themeing applied.
---@class GUIMenuLabel : GUIMenuText
--
--  Parameters (* = required)
--      font
--      fontFamily (only if font not defined)
--      fontSize (only if font not defined)
--      text
--      defaultColor    The color of the graphic when not highlighted or disabled.  Defaults to
--                      MenuStyle.kLightGrey.
--      disabledColor   The color of the graphic when disabled.  Defaults to MenuStyle.kDarkGrey.
--      highlightColor  The color of the graphic when highlighted.  Defaults to
--                      MenuStyle.kHighlight.
--     *label           The text that will be displayed in this widget.
--
--  Properties:
--      FontFamily      Whether or not this object is currently being dragged by the user.
--      FontSize        Whether or not this object can be dragged by the user.
--
--  Events:
--      OnInternalFontChanged       Fires when the font file used internally (the REAL font file)
--                                  changes.  Typically not necessary except where knowing the
--                                  exact size of a text when rendered is crucial.
--      OnInternalFontScaleChanged  Fires when the scale applied to the internal text object
--                                  changes.  Typically not necessary except where knowing the
--                                  exact size of a text when rendered is crucial.
--
-- ========= For more information, visit us at http://www.unknownworlds.com ========================

Script.Load("lua/GUI/GUIUtils.lua")

local kWrapperBitPatternFieldName = "_wrappersBitPattern"

-- Map class wrapper name --> index
-- Map class wrapper index --> wrapped class creation function
-- Map wrapped class creation function --> name
local classWrappers = {}

-- Mapping:
-- [wrapper bit pattern] -->
-- {
--   [base class] --> nil or cached generated class.
-- }
local wrappedClasses = {}

-- Map wrapperName --> Wrappers required for this wrapper.
local wrapperNameToRequiredWrappers = {}

-- Set of classes that were generated by GetWrappedClass() (so we can tell which classes were auto-
-- generated).
local resultClasses = {}

local function GetClassWrapFunctionName(classWrapperName)
    local result = string.format("Get%sWrappedClass", classWrapperName)
    return result
end

-- Return the wrapper bits of a class or object.
local function GetWrapperBits(clsOrObj)
    return clsOrObj[kWrapperBitPatternFieldName] or 0
end

local function GetWrapperNameFromIndex(idx)
    local func = classWrappers[idx]
    if not func then
        return nil
    end
    local name = classWrappers[func]
    assert(name ~= nil)
    return name
end

-- Return the bit value of an individual wrapper.
local function GetWrapperBitValue(wrapperName)
    local index = classWrappers[wrapperName]
    assert(index)
    local result = bit.lshift(1, index - 1)
    
    return result
end

local function GetCachedWrappedClass(wrapperBits, baseClass)
    local classesUsingTheseWrappers = wrappedClasses[wrapperBits]
    if classesUsingTheseWrappers then
        return classesUsingTheseWrappers[baseClass]
    end
end

function GetWrappedClass(wrapperName, baseClass, errorDepth)
    errorDepth = (errorDepth or 1) + 1
    
    RequireType("string", wrapperName, "wrapperName", errorDepth)
    
    if not classWrappers[wrapperName] then
        error(string.format("No class wrapper named '%s' was defined.", wrapperName), errorDepth)
    end
    
    -- Ensure required wrappers have been applied.
    local requiredWrappers = wrapperNameToRequiredWrappers[wrapperName]
    if requiredWrappers then
        for i=1, #requiredWrappers do
            local reqdWrapper = requiredWrappers[i]
            if not GetHasWrapper(baseClass, reqdWrapper) then
                baseClass = GetWrappedClass(reqdWrapper, baseClass, errorDepth)
            end
        end
    end
    
    local wrapperBitValue = GetWrapperBitValue(wrapperName)
    local baseClassWrapperBitPattern = GetWrapperBits(baseClass)
    local combinedBitPattern = bit.bor(wrapperBitValue, baseClassWrapperBitPattern)
    
    -- Check if the wrapper has already been applied.
    if combinedBitPattern == baseClassWrapperBitPattern then
        return baseClass
    end
    
    -- Check if we have a cached version to use.
    do
        local cachedClass = GetCachedWrappedClass(combinedBitPattern, baseClass)
        if cachedClass then
            return cachedClass
        end
    end
    
    -- We need to create a new wrapped class.  We try to arrange the consecutive wrappers in a
    -- consistent manner so as to minimize the amount of functionally-identical classes we create.
    -- But, we can only rearrange _consecutive_ wrappers starting with the most-derived.
    local cleanBaseClass = baseClass
    
    if baseClassWrapperBitPattern ~= 0 then -- skip if no wrappers have been applied.
        while resultClasses[cleanBaseClass] do
            cleanBaseClass = GetBaseClass(cleanBaseClass)
            assert(cleanBaseClass) -- no way for the most basic class to be a wrapper result.
        end
    end
    
    -- Figure out which wrappers need to be re-applied in the correct order.
    local cleanBaseClassWrapperBitPattern = GetWrapperBits(cleanBaseClass)
    local missingWrappersBits = bit.band(bit.bnot(cleanBaseClassWrapperBitPattern), baseClassWrapperBitPattern)
    
    -- Add the new wrapper to the bit set.
    missingWrappersBits = bit.bor(missingWrappersBits, wrapperBitValue)
    
    -- Re-apply the wrappers in order of the index.
    local currentReconstructedClass = cleanBaseClass
    local currentIndex = 1
    local currentWrapperBits = cleanBaseClassWrapperBitPattern
    while missingWrappersBits ~= 0 do
    
        if bit.band(missingWrappersBits, 1) ~= 0 then -- apply the wrapper at this index.
            
            currentWrapperBits = bit.bor(currentWrapperBits, bit.lshift(1, currentIndex - 1))
            local cachedClass = GetCachedWrappedClass(currentWrapperBits, currentReconstructedClass)
            if cachedClass then
                
                -- Found a preexisting class with this wrapper applied to the base class.
                currentReconstructedClass = cachedClass
            else
    
                -- No class exists with this wrapper ordering yet.  Need to create it now.
                local currentWrapperCreationFunc = classWrappers[currentIndex]
                local newClassName = string.format("%s_%d", cleanBaseClass.classname, currentWrapperBits)
                assert(_G[newClassName] == nil)
                class (newClassName) (currentReconstructedClass)
                local newClass = _G[newClassName]
                ValidateClass(newClass)
                currentWrapperCreationFunc(newClass, currentReconstructedClass)
                newClass[kWrapperBitPatternFieldName] = currentWrapperBits
                
                -- Add to wrappedClasses
                local otherClassesUsingTheseBits = wrappedClasses[currentWrapperBits]
                if not otherClassesUsingTheseBits then
                    otherClassesUsingTheseBits = {}
                    wrappedClasses[currentWrapperBits] = otherClassesUsingTheseBits
                end
                otherClassesUsingTheseBits[currentReconstructedClass] = newClass
                
                -- Add to resultClasses
                resultClasses[newClass] = true
                
                currentReconstructedClass = newClass
                
            end
        end
        missingWrappersBits = bit.rshift(missingWrappersBits, 1)
        currentIndex = currentIndex + 1
    end
    
    return currentReconstructedClass
    
end

-- Automate the creation of "class wrappers" -- classes that extend a base class to add some extra
-- behavior (eg expansion, options menu interface, tooltips).
-- There are two required fields: name, and classWrapFunc.
-- name is the name of the class wrapper we're creating.
-- classWrapFunc is a function that is called to modify the new class created from the base class
-- (eg add new methods, add new properties, etc.)
-- There is one optional field: requiredWrappers.  This is the name or table of names of wrappers
-- that must be already applied to the object when this wrapper is applied.  If they are not, they
-- will be applied automatically.  All wrapper names must have been already defined when used in
-- this function (to ensure wrappers CAN be applied in the correct order).
-- Once defined, a single class can be wrapped with a call to Get______WrappedClass.
-- 
-- For example, to create an expandable version of GUIMenuDropdownChoice, we simply call
-- GetExpandableWrappedClass(GUIMenuDropdownChoice).
function DefineClassWrapper(params)
    
    RequireType("string", params.name, "params.name")
    RequireType({"table", "string", "nil"}, params.requiredWrappers, "params.requiredWrappers")
    RequireType("function", params.classBuilderFunc, "params.classBuilderFunc")

    -- Validate required wrappers
    local requiredWrappers
    if params.requiredWrappers then
        if type(params.requiredWrappers) == "string" then
            requiredWrappers = {params.requiredWrappers}
        else
            requiredWrappers = {}
            for i=1, #params.requiredWrappers do -- copy table, don't want it to get changed later!
                requiredWrappers[i] = params.requiredWrappers[i]
            end
        end
        
        -- Ensure all required wrappers have been defined already.
        for i=1, #requiredWrappers do
            local reqWrapName = requiredWrappers[i]
            if not classWrappers[reqWrapName] then
                error(string.format("Required wrapper '%s' not defined! (Ensure you've defined all required wrappers before defining a wrapper that requires them)", reqWrapName), 2)
            end
        end
    end
    
    local name = params.name
    local classBuilderFunc = params.classBuilderFunc

    if #classWrappers >= 31 then
        error(string.format("Cannot define another class wrapper!  Definition limit (32) reached!"))
    end

    if classWrappers[name] then
        error(string.format("Class wrapper named '%s' already defined!", name), 2)
    end
    
    local creationName = GetClassWrapFunctionName(name)
    if _G[creationName] ~= nil then
        error(string.format("Unable to create class wrapper '%s'.  Class wrap function would be named '%s', but that name is already in-use elsewhere!", name, creationName), 2)
    end
    
    -- Index is simply the order in which these are created.
    local index = #classWrappers + 1
    local getWrappedClassFunc = function(cls)
        local result = GetWrappedClass(name, cls)
        return result
    end
    
    _G[creationName] = getWrappedClassFunc
    
    classWrappers[name] = index
    classWrappers[index] = classBuilderFunc
    classWrappers[classBuilderFunc] = name
    
    if requiredWrappers then
        wrapperNameToRequiredWrappers[name] = requiredWrappers
    end
    
end

-- Takes a list of class wrapper names, and wraps a base class in those wrappers.  More compact way
-- of writing it.
function GetMultiWrappedClass(baseClass, wrapperList, suppressErrorOnZeroLength)
    
    ValidateClass(baseClass)
    
    if type(wrapperList) ~= "table" then
        error(string.format("Expected an array-style table for wrapperList, got %s-type instead", GetTypeName(wrapperList)), 2)
    end
    
    -- Allow this error to be suppressed, as an empty list could conceivably be the result of some
    -- future automated-system... but for regular usage, this is probably a symptom of a typo or
    -- wrong type of table being used.
    if not suppressErrorOnZeroLength and #wrapperList == 0 then
        error("Length of wrapperList was zero.  Did you accidentally make it a dictionary-type table?", 2)
    end
    
    for i=1, #wrapperList do
        local wrapperName = wrapperList[i]
        if type(wrapperName) ~= "string" then
            error(string.format("Expected a string for wrapperList[%d], got %s-type instead", i, GetTypeName(wrapperName)), 2)
        end
        
        if classWrappers[wrapperName] == nil then
            error(string.format("Wrapper named '%s' was not defined.", wrapperName), 2)
        end
    end
    
    local requestedBits = 0
    for i=1, #wrapperList do
        local wrapperBitValue = GetWrapperBitValue(wrapperList[i])
        requestedBits = bit.bor(requestedBits, wrapperBitValue)
    end
    
    -- Wrap the class up one wrapper at a time.
    local currentClass = baseClass
    local idx = 1
    while requestedBits ~= 0 do
        if bit.band(1, requestedBits) ~= 0 then
            local wrapperName = GetWrapperNameFromIndex(idx)
            assert(wrapperName)
            currentClass = GetWrappedClass(wrapperName, currentClass)
            assert(currentClass)
        end
        idx = idx + 1
        requestedBits = bit.rshift(requestedBits, 1)
    end
    
    return currentClass
    
end

local cachedExtendedMethods = {}
-- Returns a cached copy of a method methodName, extended from a method in baseClass for
-- extendingClass.  If a cached copy is not present, a new method is defined by
-- methodFactory(extendingClass, baseClass).
function GetCachedExtendedMethod(methodName, extendingClass, baseClass, methodFactory)
    
    local key = extendingClass.classname.."_"..baseClass.classname.."_"..methodName
    if not cachedExtendedMethods[key] then
        cachedExtendedMethods[key] = methodFactory(extendingClass, baseClass)
    end
    
    assert(cachedExtendedMethods[key])
    return cachedExtendedMethods[key]
    
end

function GetHasWrapper(clsOrObj, wrapperName)
    if not classWrappers[wrapperName] then
        error(string.format("Wrapper named '%s' was not defined.", wrapperName), 2)
    end
    local wrapperBit = GetWrapperBitValue(wrapperName)
    local classWrapperBits = GetWrapperBits(clsOrObj)
    local result = bit.band(wrapperBit, classWrapperBits) ~= 0
    return result
end

